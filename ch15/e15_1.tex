\subsection{15.1-1}
    For the initial condition, $T(0) = 1 = 2^0
    = 2^n$.\\
    Assume that $T(n) = 2^n$. Since $T(n) = 
    1 + \sum_{j = 0}^{n-1}T(j)$, then $T(n+1)
    = 1 + \sum_{j = 0}^{n}T(j)$ = $1 + \sum
    _{j = 0}^{n - 1}T(j) + T(n) = 2T(n) = 
    2^{n+1}$, therefore equation (15.4) follows
    equation (15.3) and the initial condition
    $T(0) = 1$.
\subsection{15.2-2}
    Consider the rod with length 3 inches, the 
    price for a cut of length 1 inch is 1, and
    the price for a cut of length 2 inch is
    5, and the price of a cut of length 3 is 7.
    Since the cut of length 2 has the largest
    density, the resulting cutting then would be
    2 pieces, 1 inch and 2 inches, which has a
    total revenue of 6, but the cut of length 3
    has a total revenue of 7, therefore the 
    greedy approach does not work in this case.
\subsection{15.2-3}
    We can use the same algorithm of original rod-
    cutting problem, but each time when $p[i]$ 
    is called, substract it with the extra cost $c$.
\subsection{15.2-4}
    Modify $\proc{Memorized-Cut-Rod-Aux}$ as below:
    \begin{codebox}
        \Procname{$\proc{Memorized-Cut-Rod-Aux}(p, n, r)$}
        \li \If $r[n] \ge 0$
            \Then
        \li     \Return $r[n]$
            \End
        \li \If $n \isequal 0$
            \Then
        \li     $q \gets 0$
        \li \Else $q \gets -\infty$
        \li     \For $i \gets 1 \To n$
                \Do
        \li         $t \gets p[i] + \proc{Memorized-Cut-Rod-Aux}(p, n - 1, r)$
        \li         \If $q < t$
                    \Then
        \li             $s \gets i$
        \li             $q \gets t$
                    \End
        \li         $l[i] \gets s$
                \End
            \End
        \li $r[n] \gets q$
        \li \Return $q, l$
    \end{codebox}
    Then use similar procedure as $\proc{Print-Cut-Rod-Solution}$ to
    compute the actual solution.
\subsection{15.2-5}
    These are the top-down version and bottom-up version
    of the algorithm.
    \begin{codebox}
        \Procname{$\proc{Top-Down-Compute-Fibo}(n)$}
        \li let $r[0\twodots n+1]$ be a new array
        \li $\proc{Top-Down-Compute-Fibo-Aux}(n, r)$
    \end{codebox}
    \begin{codebox}
        \Procname{$\proc{Top-Down-Compute-Fibo-Aux}(n, r)$}
        \li \If $r[n] \ge 0$
            \Then
        \li     \Return $r[n]$
            \End
        \li \If $n \isequal 0$
            \Then
        \li     $q = 0$
        \li \ElseIf $n \isequal 1$
            \Then
        \li     $q = 1$
        \li \Else 
        \li     $q = \proc{Top-Down-Compute-Fibo-Aux}(n-1, r)$
        \zi     $+ \proc{Top-Down-Compute-Fibo-Aux}(n-2, r)$
            \End
        \li $r[n] = q$
        \li \Return $q$
    \end{codebox}
    \begin{codebox}
        \Procname{$\proc{Bottom-Up-Compute-Fibo-Aux}(n)$}
        \li $x \gets 0$
        \li $y \gets 1$
        \li \For $i \gets 0 \To n$
            \Do
        \li     $\id{temp}\gets x$
        \li     $x \gets y$
        \li     $y \gets \id{temp}+y$
            \End
        \li \Return $\id{temp}$
    \end{codebox}
    The bottom-up version is faster than the 
    top-down version for large data set 
    in that it does not have to
    traverse the table.
